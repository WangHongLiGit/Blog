# react笔记分享（一）：基本理解原理

`本人在创建个人博客时所用的技术栈为：react+mongoDB+express。推荐一个非常好的react教学视频，[https://ke.qq.com/course/337748?taid=2498021699168084](https://ke.qq.com/course/337748?taid=2498021699168084) ，对于react来说靠自己啃书的话效率时很低的 ，建议管理看视频学习 ，好了废话不多说，直接上干货`

## 1.第一个React App

- 在我们安装node的时候  就自动安装了npm   但是npm是国外镜像   速度慢  我们一般都用cnpm

  ```javascript
  # 安装cnpm命令
  npm install -g cnpm --registry=https://registry.npm.taobao.org
  # 设置npm源
  npm config set registry https://registry.npm.taobao.org
  ```

- 安装完cnpm之后    可以构建react环境

  ```javascript
  # 安装全局的create-react-app命令
  cnpm install -g create-react-app
  # 创建my-app工程  my-app是项目的名字 当然也可以用其他的名字
  create-react-app my-app
  # 进入项目目录
  cd my-app
  # 启动工程  启动后默认运行到3000端口  浏览器会自动弹出
  npm start
  ```

- 启动成功后  浏览器自动弹出

## 2.理解React的5个小例子 (基础)

- Demo1:简单定义一个点赞按钮

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      <button class="button1">点赞</button>
  </body>
      <script>
          /**  基本点赞按钮：
           * 
           *      缺点: 1.不严谨性————————>有可能innerHTML被别人更改了  用这个作为判		   *	          断依据不严谨
           *           2.复用性很低————————>如果再要一个按钮的话  就得重新定义一遍监听
           * 
           */
          let button1=document.getElementsByClassName("button1")[0];
          button1.addEventListener("click",function(){
              if(button1.innerHTML=="点赞"){
                  button1.innerHTML="已赞";
                  button1.style.color="red"
                  button1
              }else{
                  button1.innerHTML="点赞";
                  button1.style.color="black";
              }
          })    
      
      </script>
  </html>
  ```

- Demo2: 定义了状态state和操作状态的方法setState()  还有渲染方法render()    这里会有一些ES6的知识

  c'c

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      <button class="button">点赞</button>
  </body>
      <script>
          /**  单向数据流的点赞按钮
           * 
           *      特点1；定义了state  setState()  render() 这三个方法    实现操作状态  状态渲			*			 染界面的单项数据流
           *           ：定义了状态    这样可以使页面状态的判断更加严密
           * 
           */
          let button=document.getElementsByClassName("button")[0];
          
          let state={
              like:false
          }
          function setState(newState){
              state={...state,...newState};
              render();
          }
          function render(){
              if(state.like){
                  button.style.color="red"
                  button.innerHTML="已赞"
              }else{
                  button.style.color="black"
                  button.innerHTML="点赞"
              }
          }
          button.addEventListener("click",function(){
              setState({like:!state.like})
          })
          
      
      </script>
  </html>
  ```

- Demo3：针对上一个Demo  我们将脱离html   全部使用 js 来生成   这里的root标签只是一个最外层的容器罢了    单纯的使用js来构建为对象实例化编程做好基础

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      <div class="root"></div>
      
  </body>
      <script>
          /**  单向数据流的点赞按钮  + 纯js生成点赞按钮
           * 
           *      特点1；定义了state  setState()  render() 这三个方法    实现操作状态  状态渲染					  界面的单项数据流
           *           ：定义了状态    这样可以使页面状态的判断更加严密
           *           
           *           ：纯js生成点赞按钮脱离html的   为对象实例化编程做好基础
           */
          let root=document.getElementsByClassName("root")[0];
          
          let state={
              like:false
          }
          function setState(newState){
              state={...state,...newState};
              render();
          }
          function render(){
                  root.innerHTML=`
                      <button class="button" onclick="handleClick()" style="color:${state.like?"red":"black"}">${state.like?"已赞":"点赞"}</button>
                  `
          }
          function handleClick(){
              setState({like:!state.like})
          }
          render()
      </script>
  </html>
  ```

- Demo4: 使用ES6的封装类   将我们的按钮封装   这样我们使用的时候直接实例化就可以生成一个按钮    ES6类的封装是react组件复用的基础    如果对ES6不算太熟悉的话   可以看一看作者的  [ES6重点整理](http://)

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      <div class="root"></div>
      
  </body>
      <script>
          /**  单向数据流的点赞按钮  + 纯js生成点赞按钮  + 用面向对象的方式生成组件
           * 
           *      特点1；定义了state  setState()  render() 这三个方法    实现操作状态  状态渲染						界面的单项数据流
           *           ：定义了状态    这样可以使页面状态的判断更加严密
           *           
           *           ：纯js生成点赞按钮脱离html的   为对象实例化编程做好基础
           * 
           *           : 纯js生成的目的就是————————>将一个组件的 M V C  都封装成一个类  
           */
          let root=document.getElementsByClassName("root")[0];
          
          //ES6类的封装    
          class Button{          
              constructor(){
                  this.state={
                      like:false
                  }
              }
              setState(newState){
                  this.state={...this.state,...newState};
                  render();
              }
              render(){
                  return `<button class="button" onclick="handleClick()" style="color:${this.state.like?"red":"black"}">${this.state.like?"已赞":"点赞"}</button>
                      ` 
              }
          }
          let botton1=new Button();
  
  
      </script>
  </html>
  ```

- Demo5: 这样会有一个问题 ： 我们再定义一个组件的时候  比如再定义一个Header组件   还要再类中定义一个setState方法   似乎每一个组件都要定义这个重复的方法    这样显然增加了代码的冗余   所以我们用ES6中的类的继承   将这个方法放在父类中   所有继承父类的子类（子组件）就自然有了这个方法

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Document</title>
  </head>
  <body>
      <div class="root"></div>
      
  </body>
      <script>
          /**  单向数据流的点赞按钮  + 纯js生成点赞按钮  + 用面向对象的方式生成组件
           * 
           *      特点1；定义了state  setState()  render() 这三个方法    实现操作状态  状态渲染						界面的单项数据流
           *           ：定义了状态    这样可以使页面状态的判断更加严密
           *           
           *           ：纯js生成点赞按钮脱离html的   为对象实例化编程做好基础
           * 
           *           : 纯js生成的目的就是————————>将一个组件的 M V C  都封装成一个类  
           * 
           *           : setState()方法的冗余性太大   利用类的继承的方法  就可以将公用的方法提取到							父类中
           */
          let root=document.getElementsByClassName("root")[0];
  
          class Component{
              setState(newState){
                  this.state={...this.state,...newState};
                  render();
              }
          }
          
          class Button extends Component{
              constructor(){
                  super()
                  this.state={
                      like:false
                  }
              }
              render(){
                  return `<button class="button" onclick="handleClick()" style="color:${this.state.like?"red":"black"}">${this.state.like?"已赞":"点赞"}</button>
                      ` 
              }
          }
          
  
          class Title extends Component{
              constructor(){
                  super()
                  this.state={
                      like:false
                  }
              }
              render(){
                  return `<button class="button" onclick="handleClick()" style="color:${this.state.like?"red":"black"}">${this.state.like?"已赞":"点赞"}</button>
                      ` 
              }
          }
  
          
          let botton1=new Button();
  
  
      </script>
  </html>
  ```

  

  

  

